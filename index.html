<!DOCTYPE html>
<!--

    Maded by Fl√°vio Pavim
    https://flaviopavim.com.br

-->
<html>
    <head>
        <title>Checkers game in Javascript</title>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link href="css/style.css" rel="stylesheet" type="text/css"/>
    </head>
    <body>
        <canvas id="board" width="800" height="800"></canvas>

        <script>

            /*
             * Javascript Checkers game
             * 
             * 1. Pawn
             * 2. Knight
             * 3. Bishop
             * 4. Rook
             * 5. Queen
             * 6. King
             */

            let pieces = [
                [0, 2, 0, 2, 0, 2, 0, 2],
                [2, 0, 2, 0, 2, 0, 2, 0],
                [0, 2, 0, 2, 0, 2, 0, 2],
                [0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 2, 0, 0],
                [1, 0, 1, 0, 1, 0, 1, 0],
                [0, 1, 0, 1, 0, 1, 0, 1],
                [1, 0, 1, 0, 1, 0, 1, 0]
            ];

            /*
             * Draw the board
             */

            const canvas = document.getElementById("board");
            const ctx = canvas.getContext("2d");

            const size = 8;                    // Number of rows/columns (8x8 board)
            const tile = canvas.width / size;  // Pixel size of each square

            const light = "#f0d9b5";           // Light square color
            const dark = "#b58863";           // Dark square color
//            const light = "#74b9ff";
//            const dark = "#0984e3";

            // Draws the 8x8 checkerboard
            function drawBoard() {
                for (let r = 0; r < size; r++) {
                    for (let c = 0; c < size; c++) {

                        // Dark squares appear when row+col is odd
                        const isDark = (r + c) % 2 === 1;

                        ctx.fillStyle = isDark ? dark : light;
                        ctx.fillRect(c * tile, r * tile, tile, tile);
                    }
                }
            }

            drawBoard();

            /*
             * Draw pieces
             */

            function drawPiece(r, c) {

                const piece = pieces[r][c]; // <-- pega a pe√ßa correta!

                const x = c * tile + tile / 2;    // center X
                const y = r * tile + tile / 2;    // center Y
                const radius = tile * 0.35;       // radius

                // Circle base
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fillStyle = piece == 1 ? "#ffffff" : "#000000"; // branca ou preta
                ctx.fill();

                // Label
//                const label = labels[piece - 1]; // letra correspondente
                const label = "Pawn"; // letra correspondente
                ctx.fillStyle = piece == 1 ? "#000000" : "#ffffff"; // contraste
                ctx.font = (tile * 0.18) + "px Arial";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(label, x, y);
            }

            function drawPieces() {
                for (let r = 0; r < size; r++) {
                    for (let c = 0; c < size; c++) {
                        if (pieces[r][c] > 0) {
                            drawPiece(r, c);
                        }
                    }
                }
            }

            drawPieces();


            /*
             * Game functions
             */

            function verifyPoints(pieces) {

                /*
                 * Verify a player's points.
                 * Used to determine the winner
                 * in case of a draw or checkmate.
                 * 
                 * The minimum is 6, the value of the King.
                 * Below 6 means game over.
                 */

                let points = 0;
                for (let r = 0; r < pieces.length; r++) {
                    for (let c = 0; c < pieces[r].length; c++) {
                        points += pieces[r][c];
                    }
                }
                return points;
            }

            let turn = 1; // 0 - not started, 1 - white piece, 2 - black piece
            let selectedPieceX = -1; // Selected piece
            let selectedPieceY = -1; // Selected piece

            /*
             * GET MOVES
             * some functions that returns possible moves
             */

            function filterMoves(moves) {

                // Filter moves inside board

                let filteredMoves = [];
                for (let i = 0; i < moves.length; i++) {
                    if (
                            moves[i][0] >= 0 && moves[i][0] <= 7 &&
                            moves[i][1] >= 0 && moves[i][1] <= 7
                            ) {
                        filteredMoves.push([moves[i][0], moves[i][1]]);
                    }
                }

                return filteredMoves;
            }

            function getBishopMoves(r, c) {

                let moves = [];

                // Generate diagonal moves in all 4 directions
                for (let i = 1; i <= 8; i++) {
                    if (r + i < 8 && c + i < 8) {
                        if (pieces_white[r + i][c + i] > 0) { // if has white piece
                            break;
                        }
                        // Down-right diagonal
                        moves.push([r + i, c + i]);
                        if (pieces_black[r + i][c + i] > 0) { // if has black piece
                            break;
                        }
                    }
                }

                for (let i = 1; i <= 8; i++) {
                    if (r + i < 8 && c - i >= 0) {
                        if (pieces_white[r + i][c - i] > 0) { // if has white piece
                            break;
                        }
                        // Down-left diagonal
                        moves.push([r + i, c - i]);
                        if (pieces_black[r + i][c - i] > 0) { // if has black piece
                            break;
                        }
                    }
                }

                for (let i = 1; i <= 8; i++) {
                    if (r - i >= 0 && c + i < 8) {
                        if (pieces_white[r - i][c + i] > 0) { // if has white piece
                            break;
                        }
                        // Up-right diagonal
                        moves.push([r - i, c + i]);
                        if (pieces_black[r - i][c + i] > 0) { // if has black piece
                            break;
                        }
                    }
                }

                for (let i = 1; i <= 8; i++) {
                    if (r - i >= 0 && c - i >= 0) {
                        if (pieces_white[r - i][c - i] > 0) { // if has white piece
                            break;
                        }
                        // Up-left diagonal
                        moves.push([r - i, c - i]);
                        if (pieces_black[r - i][c - i] > 0) { // if has black piece
                            break;
                        }
                    }
                }

                // Apply extra filtering (board limits, collisions, etc)
                moves = filterMoves(moves);

                return moves;
            }

            function getPawnMovesss(r, c, blackPiece) {
                let moves = [];
                if (!blackPiece) {
                    if (r - 1 >= 0) { // pra frente (cima)
                        if (c + 1 < 8) {
                            if (pieces[r - 1][c + 1] == 0) {
                                moves.push([r - 1, c + 1]);
                            }
                            if (pieces[r - 1][c + 1] == 2) {
                                if (pieces[r - 2][c + 2] == 0) {
                                    //pode comer
                                    moves.push([r - 2, c + 2]);
                                }
                            }
                        }
                        if (c - 1 >= 0) {
                            if (pieces[r - 1][c - 1] == 0) {
                                moves.push([r - 1, c - 1]);
                            }
                            if (pieces[r - 1][c - 1] == 2) {
                                if (pieces[r - 2][c - 2] == 0) {
                                    //pode comer
                                    moves.push([r - 2, c - 2]);
                                }
                            }
                        }
                    }
                }
                if (blackPiece) {
                    if (r + 1 < 8) { // pra tr√°s (baixo)
                        if (c + 1 < 8) {
                            if (pieces[r + 1][c + 1] == 0) {
                                moves.push([r + 1, c + 1]);
                            }
                            if (pieces[r + 1][c + 1] == 1) {
                                if (pieces[r + 2][c + 2] == 0) {
                                    moves.push([r + 2, c + 2]);
                                }
                            }
                        }
                        if (c - 1 >= 0) {
                            if (pieces[r + 1][c - 1] == 0) {
                                moves.push([r + 1, c - 1]);
                            }
                            if (pieces[r + 1][c - 1] == 1) {
                                if (pieces[r + 2][c - 2] == 0) {
                                    moves.push([r + 2, c - 2]);
                                }
                            }
                        }
                    }
                }
                moves = filterMoves(moves);
                return moves;
            }
            
//            function getChains(r, c, blackPiece, visited = new Set()) {
//    const enemy = blackPiece ? 1 : 2;
//    let captures = [];
//
//    // Para evitar loops
//    const key = `${r},${c}`;
//    if (visited.has(key)) return [];
//    visited.add(key);
//
//    const dirs = blackPiece
//        ? [[1,1],[1,-1]]
//        : [[-1,1],[-1,-1]];
//
//    for (let i = 0; i < dirs.length; i++) {
//        const dr = dirs[i][0];
//        const dc = dirs[i][1];
//
//        const r1 = r + dr;
//        const c1 = c + dc;
//        const r2 = r + dr*2;
//        const c2 = c + dc*2;
//
//        // dentro do tabuleiro
//        if (r2 < 0 || r2 >= 8 || c2 < 0 || c2 >= 8) continue;
//
//        // h√° inimigo e depois espa√ßo pra pousar
//        if (pieces[r1][c1] == enemy && pieces[r2][c2] == 0) {
//            captures.push([r2, c2]);
//
//            // continuar combo
//            const more = getChains(r2, c2, blackPiece, new Set(visited));
//            captures.push(...more);
//        }
//    }
//
//    return captures;
//}
//function getPawnMoves(r, c, blackPiece) {
//    let moves = [];
//
//    const enemy = blackPiece ? 1 : 2;
//    const dirs = blackPiece
//        ? [[1,1],[1,-1]]
//        : [[-1,1],[-1,-1]];
//
//    // movimentos simples + primeira captura
//    for (let i = 0; i < dirs.length; i++) {
//        const dr = dirs[i][0];
//        const dc = dirs[i][1];
//
//        const r1 = r + dr;
//        const c1 = c + dc;
//        const r2 = r + dr*2;
//        const c2 = c + dc*2;
//
//        // dentro do tabuleiro
//        if (r1 < 0 || r1 >= 8 || c1 < 0 || c1 >= 8) continue;
//
//        // movimento simples
//        if (pieces[r1][c1] == 0) {
//            moves.push([r1, c1]);
//        }
//
//        // captura inicial
//        if (pieces[r1][c1] == enemy && r2 >= 0 && r2 < 8 && c2 >= 0 && c2 < 8) {
//            if (pieces[r2][c2] == 0) {
//                moves.push([r2, c2]);
//            }
//        }
//    }
//
//    // üî• capturas em sequ√™ncia
//    const chains = getChains(r, c, blackPiece);
//    moves.push(...chains);
//
//    moves = filterMoves(moves);
//    return moves;
//}
function getChains(r, c, blackPiece, visited = new Set()) {
    const enemy = blackPiece ? 1 : 2;
    let captures = [];

    const dirs = [
        [-1,  1],   // up-right
        [-1, -1],   // up-left
        [ 1,  1],   // down-right
        [ 1, -1]    // down-left
    ];

    const key = `${r},${c}`;
    if (visited.has(key)) return [];
    visited.add(key);

    for (let i = 0; i < dirs.length; i++) {
        const dr = dirs[i][0];
        const dc = dirs[i][1];

        const r1 = r + dr;
        const c1 = c + dc;
        const r2 = r + dr*2;
        const c2 = c + dc*2;

        if (r2 < 0 || r2 >= 8 || c2 < 0 || c2 >= 8) continue;

        if (pieces[r1][c1] == enemy && pieces[r2][c2] == 0) {
            captures.push([r2, c2]);

            const more = getChains(r2, c2, blackPiece, new Set(visited));
            captures.push(...more);
        }
    }

    return captures;
}

function getPawnMoves(r, c, blackPiece) {
    let moves = [];

    const enemy = blackPiece ? 1 : 2;

    // ------ MOVIMENTO SIMPLES (igual estava!) ------
    if (!blackPiece) {
        if (r - 1 >= 0) {
            if (c + 1 < 8 && pieces[r - 1][c + 1] == 0)
                moves.push([r - 1, c + 1]);
            if (c - 1 >= 0 && pieces[r - 1][c - 1] == 0)
                moves.push([r - 1, c - 1]);
        }
    } else {
        if (r + 1 < 8) {
            if (c + 1 < 8 && pieces[r + 1][c + 1] == 0)
                moves.push([r + 1, c + 1]);
            if (c - 1 >= 0 && pieces[r + 1][c - 1] == 0)
                moves.push([r + 1, c - 1]);
        }
    }

    // ------ CAPTURAS INICIAIS (em 4 dire√ß√µes) ------
    const dirs = [
        [-1,  1],
        [-1, -1],
        [ 1,  1],
        [ 1, -1]
    ];

    for (let i = 0; i < dirs.length; i++) {
        const dr = dirs[i][0];
        const dc = dirs[i][1];

        const r1 = r + dr;
        const c1 = c + dc;
        const r2 = r + dr*2;
        const c2 = c + dc*2;

        if (r2 < 0 || r2 >= 8 || c2 < 0 || c2 >= 8) continue;

        if (pieces[r1][c1] == enemy && pieces[r2][c2] == 0) {
            moves.push([r2, c2]);
        }
    }

    // ------ CAPTURAS EM PROGRESS√ÉO (combo) ------
    const chains = getChains(r, c, blackPiece);
    moves.push(...chains);

    moves = filterMoves(moves);
    return moves;
}

            /*
             * HIGHLIGHT
             */

//            function drawMarkedSquares() {
//                for (let i = 0; i < markedSquares.length; i++) {
//                    const r = markedSquares[i][0];
//                    const c = markedSquares[i][1];
//
//                    ctx.fillStyle = "rgba(255, 0, 0, 0.35)";
//                    ctx.fillRect(c * tile, r * tile, tile, tile);
//                }
//            }


            let markedSquares = [];

            function drawMarkedSquares() {
                for (let i = 0; i < markedSquares.length; i++) {

                    const r = markedSquares[i][0];
                    const c = markedSquares[i][1];

                    const x = c * tile;
                    const y = r * tile;

                    const margin = tile * 0.15; // margem para deixar no centro
                    const size = tile - margin * 2;

                    ctx.strokeStyle = "#00b894";    // verde
                    ctx.lineWidth = 2;
                    ctx.setLineDash([6, 4]);        // dashed

                    ctx.strokeRect(x + margin, y + margin, size, size);

                    ctx.setLineDash([]); // reseta (importante)
                }
            }


            function redrawAll() {
                drawBoard();
                drawPieces();
                drawMarkedSquares();
            }

            /*
             * Click
             */

            canvas.addEventListener("click", function (e) {

//                if (turn == 1) {

                    const rect = canvas.getBoundingClientRect();

                    // posi√ß√£o real do clique dentro do canvas
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;

                    // converte coordenadas ‚Üí quadrado
                    const c = Math.floor(x / tile); // coluna
                    const r = Math.floor(y / tile); // linha

                    console.log("Quadrado clicado:", r, c);

                    let moved = false;

                    if (selectedPieceX != -1) {
                        for (let i = 0; i < markedSquares.length; i++) {
                            if (markedSquares[i]) {

                                let x = markedSquares[i][0];
                                let y = markedSquares[i][1];

                                if (x >= 0 && x <= 7 && y >= 0 && y <= 7) {
                                    if (x == r && y == c) {
                                        moved = true;

                                        let piece = pieces[selectedPieceX][selectedPieceY];

                                        pieces[r][c] = piece;
                                        
                                        
                                        if (piece==1 && r==0) {
                                            //chegou no fim, vira dama
                                        }
                                        if (piece==2 && r==8) {
                                            //chegou no fim, vira dama
                                        }
                                        
                                        
                                        let countMoves=selectedPieceX-r;
                                        countMoves*=countMoves<0?-1:1; // if negative
                                        
                                        if (countMoves==2) { // walked 2 steps
                                            let xx=(selectedPieceX+r)/2;
                                            let yy=(selectedPieceY+c)/2;
                                            pieces[xx][yy] = 0; // 
                                        }
                                        
                                        pieces[selectedPieceX][selectedPieceY] = 0;
                                        selectedPieceX = -1;
                                        selectedPieceY = -1;
                                        markedSquares = []; // Clear marked squares

                                        turn = 2;

                                    }
                                }

                            }
                        }
                    }

                    if (!moved) {
                        //} else  {

                        let piece = pieces[r][c];

                        //selectedPieceX=-1;
                        //selectedPieceY=-1;
                        markedSquares = []; // Clear marked squares

                        if (piece > 0) {
//                            console.log("Pe√ßa branca:", labels[pieceW - 1]);

                            selectedPieceX = r;
                            selectedPieceY = c;

                            let moves = [];

                            if (piece == 1)
                                moves = getPawnMoves(r, c, false);
                            if (piece == 2)
                                moves = getPawnMoves(r, c, true);
                    

                            for (let i = 0; i < moves.length; i++) {
                                markedSquares.push([moves[i][0], moves[i][1]]);
                            }


                        }
//                        if (pieceB > 0) {
//                            console.log("Pe√ßa preta:", labels[pieceB - 1]);
//                        }
                    }

                    redrawAll();

//                } else {
//                    alert("Aguarde sua vez");
//                }


            });

            /*
             * Cursor
             */

            canvas.addEventListener("mousemove", function (e) {

//                const rect = canvas.getBoundingClientRect();
//                const x = e.clientX - rect.left;
//                const y = e.clientY - rect.top;
//
//                const c = Math.floor(x / tile); // coluna
//                const r = Math.floor(y / tile); // linha
//
//                // Detectar se est√° em markedSquares
//                let isMarked = false;
//                for (let i = 0; i < markedSquares.length; i++) {
//                    if (markedSquares[i][0] === r && markedSquares[i][1] === c) {
//                        isMarked = true;
//                        break;
//                    }
//                }
//
//                // Se tiver pe√ßa branca OU for um quadrado marcado ‚Üí pointer
//                if (pieces_white[r][c] > 0 || isMarked) {
//                    canvas.style.cursor = "pointer";
//                } else {
//                    canvas.style.cursor = "default";
//                }

            });

            /*
             * Machine moves
             */

            function ia() {
                turn = 1;
            }


            window.setInterval(function () {
                if (turn == 2) {
                    ia();
                }
            }, 100);

        </script>
    </body>
</html>
